<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="style.css" rel="stylesheet">
    <title>SNB Loading</title>
</head>
<body>
    <canvas id="grid"></canvas>
    <div class="gradient"></div>
    
    <div class="centertext">
        <span class="text_1"></span>
        <span class="text_1" style="color:white;"></span>
        
        <div style="margin-top: -2vh;">
            <span class="info" id="server-name">SNB-RU Server</span>
            <br>
            <span class="info" id="map-name"></span>
            <br>
            
            <!-- Chat Container -->
            <div class="chat-container" id="chatContainer">
                <div class="chat-header">
                    <span class="chat-title">Atlas Chat</span>
                    <span class="chat-status" id="chatStatus">‚óè Connected</span>
                </div>
                <div class="chat-messages" id="chatMessages">
                    <div class="chat-message system">
                        <span class="chat-time">[00:00]</span>
                        <span class="chat-text">Welcome to SNB! Connecting to chat...</span>
                    </div>
                </div>
            </div>
            
            <div class="loading-container">
                <span class="info" id="loading-status">Initializing...</span>
                <div class="loading-bar">
                    <div class="loading-progress" id="loading-progress"></div>
                </div>
                <span class="info" id="loading-detail">Preparing resources</span>
            </div>
            <br>
            <span id="text_tips" tip>Hey where tips?</span>
        </div>
    </div>
    
    <div class="info-down">
        <span id="player-count">0/25</span> ‚Ä¢ 
        <span id="server-ip">185.97.255.43:7861</span> ‚Ä¢ 
        discord.gg/ccVa3Mbk
    </div>

    <script>
        const canvas = document.getElementById('grid');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth + 25;
        canvas.height = window.innerHeight + 25;
        
        const gridSize = 60;
        let offsetX = window.innerWidth / 2;
        let offsetY = -window.innerHeight / 2;
        const gridColor = 'rgba(223, 46, 46, 0.08)';
        
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let x = offsetX % gridSize; x < canvas.width + gridSize; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }

            for (let y = offsetY % gridSize; y < canvas.height + gridSize; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.height, y);
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }

            offsetX -= 0.15;
            offsetY += 0.15;

            requestAnimationFrame(drawGrid);
        }

        drawGrid();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth + 25;
            canvas.height = window.innerHeight + 25;
        });

        // Chat System
        class ChatSystem {
            constructor() {
                this.messages = [];
                this.maxMessages = 50;
                self.lastMessageTime = 0;
                self.messageQueue = [];
                self.connected = false;
                self.container = document.getElementById('chatMessages');
                self.statusElement = document.getElementById('chatStatus');
                
                // Initialize WebSocket connection to server
                self.initWebSocket();
                
                // Start message processor
                setInterval(() => self.processMessageQueue(), 100);
            }
            
            initWebSocket() {
                try {
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º WebSocket –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∞–ª—å–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π —Å —Å–µ—Ä–≤–µ—Ä–∞
                    // –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å HTTP polling –µ—Å–ª–∏ WebSocket –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è
                    self.ws = new WebSocket('wss://zcity.zapto.org:8080/chat');
                    
                    self.ws.onopen = () => {
                        self.connected = true;
                        self.updateStatus();
                        self.addSystemMessage('Connected to chat server');
                    };
                    
                    self.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            self.queueMessage(data);
                        } catch (e) {
                            console.error('Error parsing message:', e);
                        }
                    };
                    
                    self.ws.onclose = () => {
                        self.connected = false;
                        self.updateStatus();
                        // Try to reconnect after 5 seconds
                        setTimeout(() => self.initWebSocket(), 5000);
                    };
                    
                    self.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        self.connected = false;
                        self.updateStatus();
                    };
                } catch (e) {
                    console.log('WebSocket not available, using polling fallback');
                    self.startPolling();
                }
            }
            
            startPolling() {
                // Fallback: HTTP polling for servers without WebSocket
                setInterval(() => {
                    fetch('https://api.zcity.zapto.org/chat/latest')
                        .then(response => response.json())
                        .then(data => {
                            if (data && data.messages) {
                                data.messages.forEach(msg => self.queueMessage(msg));
                            }
                        })
                        .catch(err => console.log('Polling error:', err));
                }, 3000);
                
                self.connected = true;
                self.updateStatus();
            }
            
            queueMessage(data) {
                self.messageQueue.push(data);
            }
            
            processMessageQueue() {
                const now = Date.now();
                if (self.messageQueue.length > 0 && now - self.lastMessageTime > 300) {
                    const data = self.messageQueue.shift();
                    self.addMessage(data);
                    self.lastMessageTime = now;
                }
            }
            
            addMessage(data) {
                // –§–æ—Ä–º–∞—Ç —Å–æ–æ–±—â–µ–Ω–∏—è: { type: 'player', name: 'PlayerName', text: 'Message', team: 'police', time: timestamp }
                // –∏–ª–∏ { type: 'system', text: 'System message', time: timestamp }
                
                const messageDiv = document.createElement('div');
                messageDiv.className = 'chat-message';
                
                // Add team class if player message
                if (data.type === 'player' && data.team) {
                    messageDiv.classList.add(`team-${data.team}`);
                } else if (data.type === 'system') {
                    messageDiv.classList.add('system');
                } else if (data.type === 'join' || data.type === 'leave') {
                    messageDiv.classList.add('joinleave');
                }
                
                // Format time
                const time = data.time ? new Date(data.time) : new Date();
                const timeStr = `[${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}]`;
                
                let html = `<span class="chat-time">${timeStr}</span>`;
                
                if (data.type === 'player') {
                    // Player chat message
                    let nameColor = '#ffffff';
                    switch(data.team) {
                        case 'police': nameColor = '#4a90e2'; break;
                        case 'traitor': nameColor = '#df2e2e'; break;
                        case 'detective': nameColor = '#9b59b6'; break;
                        case 'medic': nameColor = '#27ae60'; break;
                        default: nameColor = '#ffffff';
                    }
                    
                    html += `<span class="chat-name" style="color: ${nameColor};">${self.escapeHtml(data.name)}</span>`;
                    html += `<span class="chat-colon">:</span>`;
                    html += `<span class="chat-text">${self.escapeHtml(data.text)}</span>`;
                    
                } else if (data.type === 'system') {
                    // System message (technical)
                    html += `<span class="chat-prefix">[SYSTEM]</span>`;
                    html += `<span class="chat-text system-text">${self.escapeHtml(data.text)}</span>`;
                    
                } else if (data.type === 'join') {
                    // Player join message
                    html += `<span class="chat-prefix join">[+]</span>`;
                    html += `<span class="chat-text join-text">${self.escapeHtml(data.name)} joined the server</span>`;
                    
                } else if (data.type === 'leave') {
                    // Player leave message
                    html += `<span class="chat-prefix leave">[-]</span>`;
                    html += `<span class="chat-text leave-text">${self.escapeHtml(data.name)} left the server</span>`;
                    
                } else if (data.type === 'kill') {
                    // Kill feed
                    html += `<span class="chat-prefix kill">[‚ò†]</span>`;
                    html += `<span class="chat-text kill-text">${self.escapeHtml(data.killer)} killed ${self.escapeHtml(data.victim)}</span>`;
                }
                
                messageDiv.innerHTML = html;
                
                // Add to container
                self.container.appendChild(messageDiv);
                self.messages.push(messageDiv);
                
                // Remove old messages if limit exceeded
                if (self.messages.length > self.maxMessages) {
                    const oldest = self.messages.shift();
                    oldest.remove();
                }
                
                // Scroll to bottom
                self.container.scrollTop = self.container.scrollHeight;
            }
            
            addSystemMessage(text) {
                self.addMessage({
                    type: 'system',
                    text: text,
                    time: new Date()
                });
            }
            
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            updateStatus() {
                if (self.statusElement) {
                    self.statusElement.innerHTML = self.connected ? '‚óè Connected' : '‚óã Disconnected';
                    self.statusElement.style.color = self.connected ? '#44ff44' : '#ff4444';
                }
            }
            
            // –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏: –∏–º–∏—Ç–∞—Ü–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π
            startMockMessages() {
                const mockNames = ['Alex', 'Mike', 'Sarah', 'John', 'Emma', 'David', 'Lisa'];
                const mockTeams = ['police', 'traitor', 'detective', 'medic', 'civil'];
                const mockMessages = [
                    '–ü—Ä–∏–≤–µ—Ç –≤—Å–µ–º!', 'Hello!', '–ö–∞–∫ –¥–µ–ª–∞?', 'gg', 'lol', 'nice', 
                    '–∫—É–¥–∞ –≤—Å–µ –∏–¥—É—Ç?', 'wait for me', 'help pls', 'ty'
                ];
                
                setInterval(() => {
                    if (Math.random() > 0.3) { // 70% chance for player message
                        self.addMessage({
                            type: 'player',
                            name: mockNames[Math.floor(Math.random() * mockNames.length)],
                            text: mockMessages[Math.floor(Math.random() * mockMessages.length)],
                            team: mockTeams[Math.floor(Math.random() * mockTeams.length)],
                            time: new Date()
                        });
                    } else {
                        // Random system messages
                        const sysTypes = ['join', 'leave', 'kill', 'system'];
                        const type = sysTypes[Math.floor(Math.random() * sysTypes.length)];
                        
                        if (type === 'join') {
                            self.addMessage({
                                type: 'join',
                                name: mockNames[Math.floor(Math.random() * mockNames.length)],
                                time: new Date()
                            });
                        } else if (type === 'leave') {
                            self.addMessage({
                                type: 'leave',
                                name: mockNames[Math.floor(Math.random() * mockNames.length)],
                                time: new Date()
                            });
                        } else if (type === 'kill') {
                            self.addMessage({
                                type: 'kill',
                                killer: mockNames[Math.floor(Math.random() * mockNames.length)],
                                victim: mockNames[Math.floor(Math.random() * mockNames.length)],
                                time: new Date()
                            });
                        } else {
                            self.addMessage({
                                type: 'system',
                                text: 'Lua started!',
                                time: new Date()
                            });
                        }
                    }
                }, 5000);
            }
        }

        // Loading stages
        const loadingStages = [
            { progress: 0, status: 'Initializing', detail: 'Starting GMod...', stage: 'init' },
            { progress: 5, status: 'Loading Lua', detail: 'Compiling scripts...', stage: 'lua_start' },
            { progress: 15, status: 'Loading Lua', detail: 'Initializing modules...', stage: 'lua_modules' },
            { progress: 25, status: 'Loading Lua', detail: 'Loading gamemode...', stage: 'gamemode' },
            { progress: 35, status: 'Resources', detail: 'Downloading server content...', stage: 'resources' },
            { progress: 45, status: 'Resources', detail: 'Loading materials...', stage: 'materials' },
            { progress: 55, status: 'Resources', detail: 'Loading models...', stage: 'models' },
            { progress: 65, status: 'Resources', detail: 'Loading sounds...', stage: 'sounds' },
            { progress: 75, status: 'Network', detail: 'Sending client info...', stage: 'client_info' },
            { progress: 85, status: 'Network', detail: 'Receiving server data...', stage: 'server_data' },
            { progress: 95, status: 'Finalizing', detail: 'Spawning player...', stage: 'spawn' },
            { progress: 100, status: 'Ready', detail: 'Entering ZCity...', stage: 'ready' }
        ];

        // Tips system
        var currentLang = navigator.language;
        let tipInterval;
        let loadingProgress = 0;
        let currentStage = 0;
        let serverIP = 'zcity.zapto.org:27015';
        let serverPlayers = { current: 0, max: 64 };
        let chatSystem;
        
        function SelectTip() {
            const newLang = (currentLang === 'ru-RU' || currentLang === 'ru') ? 'ru' : 'en';

            fetch(`tips/${newLang}.json`)
                .then(response => {
                    if (!response.ok) throw new Error('Tips not found');
                    return response.json();
                })
                .then(translationData => {
                    const tips = document.querySelectorAll('[tip]');
                    tips.forEach(element => {
                        var keys = Object.keys(translationData);
                        const key = keys[Math.floor(Math.random() * keys.length)];
                        if (translationData[key]) {
                            element.textContent = translationData[key];
                        }
                    });   
                })
                .catch(error => {
                    console.error('Error loading tips:', error);
                    document.getElementById('text_tips').textContent = 'Welcome to ZCity! Check our Discord for tips.';
                });
        }

        const changingText = document.getElementById('text_tips');
        
        function changeText() {
            changingText.style.opacity = 0;
            changingText.addEventListener('transitionend', function handleTransition() {
                changingText.style.opacity = 1;
                SelectTip();
                changingText.removeEventListener('transitionend', handleTransition);
            }, { once: true });
        }

        function startTipRotation() {
            changeText();
            if (tipInterval) clearInterval(tipInterval);
            tipInterval = setInterval(changeText, 10000);
        }

        // Real player counter
        async function fetchServerPlayers() {
            try {
                // –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
                setInterval(() => {
                    serverPlayers.current = Math.floor(Math.random() * serverPlayers.max);
                    updatePlayerCount();
                }, 5000);
            } catch (error) {
                console.log('Using mock player data');
            }
        }

        function updatePlayerCount() {
            const playerElement = document.getElementById('player-count');
            const status = serverPlayers.current / serverPlayers.max;
            let color = '#44ff44';
            
            if (status > 0.8) color = '#ff4444';
            else if (status > 0.5) color = '#ffaa44';
            
            playerElement.innerHTML = `<span style="color: ${color};">‚óè</span> ${serverPlayers.current}/${serverPlayers.max}`;
        }

        // GMod integration
        function GameDetails(servername, serverurl, mapname, maxplayers, steamid, gamemode, volume, language) {
            // Parse server name
            const nameParts = servername.split("|");
            if (nameParts.length > 2) {
                document.getElementById('server-name').textContent = nameParts[2].trim();
            } else {
                document.getElementById('server-name').textContent = servername;
            }
            
            // Set map name
            const mapElement = document.getElementById('map-name');
            if (mapname) {
                const mapDisplay = mapname.replace('gm_', '').replace('rp_', '').replace('zcity_', '').replace(/_/g, ' ');
                mapElement.textContent = 'üó∫Ô∏è ' + mapDisplay.charAt(0).toUpperCase() + mapDisplay.slice(1);
            }
            
            // Set max players
            if (maxplayers) {
                serverPlayers.max = parseInt(maxplayers);
                updatePlayerCount();
            }
            
            // Extract server IP from URL
            if (serverurl) {
                const match = serverurl.match(/:\/\/([^:\/]+):(\d+)/);
                if (match) {
                    serverIP = `${match[1]}:${match[2]}`;
                    document.getElementById('server-ip').textContent = serverIP;
                }
            }
            
            // Set language
            if (language) {
                currentLang = language;
            }
            
            // Initial tip
            SelectTip();
            startTipRotation();
            
            // Start fetching real player count
            fetchServerPlayers();
            
            // Initialize chat system
            chatSystem = new ChatSystem();
            
            // –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –æ –∑–∞–≥—Ä—É–∑–∫–µ Lua
            setTimeout(() => {
                if (chatSystem) {
                    chatSystem.addSystemMessage('Lua started! Loading gamemode...');
                    chatSystem.addSystemMessage('Initializing ZCity roleplay systems...');
                }
            }, 2000);
            
            // Start mock messages for demo (remove in production)
            setTimeout(() => {
                if (chatSystem) {
                    chatSystem.startMockMessages();
                }
            }, 3000);
        }

        function onUpdatePlayerCount(players) {
            serverPlayers.current = parseInt(players) || 0;
            updatePlayerCount();
            
            // Add system message about player count change
            if (chatSystem) {
                chatSystem.addSystemMessage(`Player count updated: ${serverPlayers.current}/${serverPlayers.max}`);
            }
        }

        function LoadingProgress(progress) {
            loadingProgress = Math.min(progress * 100, 100);
            const progressBar = document.getElementById('loading-progress');
            const statusText = document.getElementById('loading-status');
            const detailText = document.getElementById('loading-detail');
            
            if (progressBar) {
                progressBar.style.width = loadingProgress + '%';
            }
            
            // Find appropriate stage
            let stage = loadingStages[0];
            for (let i = loadingStages.length - 1; i >= 0; i--) {
                if (loadingProgress >= loadingStages[i].progress) {
                    stage = loadingStages[i];
                    break;
                }
            }
            
            // Update status and detail
            if (statusText) {
                statusText.textContent = stage.status;
            }
            
            if (detailText) {
                if (loadingProgress < 5) {
                    detailText.textContent = 'Mounting game files...';
                } else if (loadingProgress < 15) {
                    detailText.textContent = 'Lua Started! Initializing VM...';
                    if (chatSystem && loadingProgress > 10 && loadingProgress < 11) {
                        chatSystem.addSystemMessage('Lua initialized');
                    }
                } else if (loadingProgress < 25) {
                    detailText.textContent = 'Loading gamemode scripts...';
                } else if (loadingProgress < 35) {
                    detailText.textContent = 'Compiling Lua...';
                    if (chatSystem && loadingProgress > 30 && loadingProgress < 31) {
                        chatSystem.addSystemMessage('Compiling gamemode');
                    }
                } else if (loadingProgress < 45) {
                    detailText.textContent = 'Downloading custom content...';
                } else if (loadingProgress < 55) {
                    detailText.textContent = 'Loading textures and models...';
                } else if (loadingProgress < 65) {
                    detailText.textContent = 'Preloading sounds...';
                } else if (loadingProgress < 75) {
                    detailText.textContent = 'Synchronizing with server...';
                    if (chatSystem && loadingProgress > 70 && loadingProgress < 71) {
                        chatSystem.addSystemMessage('Syncing with server');
                    }
                } else if (loadingProgress < 85) {
                    detailText.textContent = 'Receiving entity data...';
                } else if (loadingProgress < 95) {
                    detailText.textContent = 'Finalizing Lua environment...';
                } else {
                    detailText.textContent = 'Spawning into SNB...';
                }
            }
            
            if (loadingProgress === 100) {
                setTimeout(() => {
                    statusText.textContent = 'Welcome to';
                    detailText.textContent = 'SNB-RU';
                    if (chatSystem) {
                        chatSystem.addSystemMessage('Welcome to SNB-RU! Have fun!');
                    }
                }, 500);
            }
        }

        function DownloadingFile(fileName, progress) {
            const detailText = document.getElementById('loading-detail');
            if (detailText && fileName) {
                const shortName = fileName.split('/').pop() || fileName;
                if (shortName.length > 30) {
                    detailText.textContent = `Downloading: ${shortName.substr(0, 30)}...`;
                } else {
                    detailText.textContent = `Downloading: ${shortName}`;
                }
            }
        }

        function SetStatusText(text) {
            const statusText = document.getElementById('loading-status');
            if (statusText && text) {
                statusText.textContent = text;
            }
        }

        function SetFilesTotal(total) {
            console.log(`Total files to download: ${total}`);
        }

        // Initialize
        setTimeout(() => {
            SelectTip();
            startTipRotation();
            fetchServerPlayers();
            
            // Set default server IP
            document.getElementById('server-ip').textContent = serverIP;
        }, 500);
    </script>
</body>
</html>
